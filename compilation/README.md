# what is compilation?
汇编语言是什么呢？它是源代码和二进制代码之间的桥梁，它与二进制代码一一对应，同时又具备了可读性。可以说，它就是文本化的二进制代码。在发明高级语言之前，它一直是人类使用的程序语言

# 编译过程
在初学C语言时，我们都会写一个叫做hello.c的文件，通过编译(广义)这个文件（及库文件）并执行，计算机会在屏幕上显示"Hello world!"这一行字符串。但是，我们不禁发问，计算机究竟是怎样理解hello.c中的代码的？
编译是一个复杂的过程，主要是预由预处理器把源代码中的宏去掉/替换；由编译器将源代码翻译为汇编程序（这是我们的主角）；汇编程序被汇编器翻译为机器码，并链接到一起形成可执行文件。

# 生成汇编代码
gcc -Og -S hello.c   // 会生成hello.s文件，即汇编代码. win下生成好的汇编和linux下生成的汇编代码有所不同，但大体上是一样的。，示例中已linux下生成的汇编代码分析。
注意加上-Og使得到的汇编代码与源代码尽可能的对应，否则编译器优化将会使我们很难看出汇编代码与源代码的关系。

然而，这样的到的汇编代码不够简洁和整齐。我们将使用下面的方法得到反汇编代码：
首先编译源代码得到目标文件hello.o：

gcc -c -Og hello.c
然后用反汇编命令：

objdump -d hello.o

# 操作数
操作数可以是立即数、寄存器、内存地址。下面是表示这三种操作数的方法（来自x64 data sheet）：

举例来说，$5是立即数，它的值5；%rax是寄存器，它的值是寄存器%rax中的值；0xf7是内存地址，它的值是内存中地址为0x07的某种类型的值；(%rax)也是内存的地址，只不过，该地址保留在寄存器%rax中；0xf7(%rax, %rbp, 4)也是内存的地址，所有的内存寻址方式都可以写成这种类型。

详见：https://zhuanlan.zhihu.com/p/469950256